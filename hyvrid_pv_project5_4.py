# -*- coding: utf-8 -*-
"""Hyvrid PV Project5.4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T6sV5Ts5r5OnBQBh1XAuFb9-9SIi0xg-
"""

# Commented out IPython magic to ensure Python compatibility.
for var in list(globals()):
    if var.startswith('df'):
        del globals()[var]

print("ğŸ§¼ × ××—×§×• ×›×œ ×”××©×ª× ×™× ×©××ª×—×™×œ×™× ×‘Ö¾df")
# %reset -f



"""#×‘××—×‘×¨×ª ×”×–××ª ×”×•×¡×¤×ª×™ ×”×¡×¤×§ ×©×œ ×” BESS#"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import os

"""# ×©×œ×‘ ×¨××©×•×Ÿ ×œ×•×§×—×ª 17 ×¢××•×“×•×ª ×•×”×•×¤×›×ª ××•×ª× ×œ 76 ×¢××•×“×•×ª"""

# ×§×œ×˜ ×§×‘×•×¢×™×
site_capacity_kwp = 15200
grid_connection_limit_kw = 6000
bess_capacity_kwh =0.99* 35000
bess_charge_limit_kw = 6000
target_soc = 0.99
site_pv_limit=grid_connection_limit_kw+bess_charge_limit_kw
pv_start_hour=8
pv_end_hour=16

#import os

# ×§×œ×˜ ×§×‘×•×¢×™×
site_capacity_kwp = 15200
grid_connection_limit_kw = 6000
bess_capacity_kwh = 0.99 * 35000
bess_charge_limit_kw = 6000
target_soc = 0.99
site_pv_limit = grid_connection_limit_kw + bess_charge_limit_kw
pv_start_hour = 8
pv_end_hour = 16

# ×˜×¢×™× ×ª ×”×§×•×‘×¥ ××• ×™×¦×™×¨×ª × ×ª×•× ×™ ×“××”
if os.path.exists("Project data4.xlsx"):
    df = pd.read_excel("Project data4.xlsx")
    print("âœ… Loaded real data.")
else:
    from generate_dummy_data_daylight_clean_10k import generate_dummy_data
    df = generate_dummy_data()
    print("âš ï¸ Using dummy data (real data file not found).")

#×¡×™×“×•×¨ ×¢××•×“×•×ª
#××™×™×¦×¨ 17 ×¢××•×“×•×ª ××§×‘×™×œ×•×ª ×œ×¢××•×“×•×ª ×”××§×•×¨ ×©×‘×›×œ ××—×ª ××”× ××¦×•×™×™×Ÿ 1 ××• 0 ××  ×‘×¢××•×“×ª ×”××§×•×¨ ×™×© ×¢×¨×š ×—×¡×¨
for col in df.columns:
    df[f'{col}_missing'] = df[col].isna().astype(int)

#××•×¨×™×“×” ×¨×•×•×—×™× ×‘×¢××•×“×•×ª
df.columns = df.columns.str.strip()

#××™×œ×•×™×™ ×¢×¨×›×™× ×—×¡×¨×™× ×‘×¢××•×“×•×ª ××§×•×¨

# ×¢××•×“×•×ª ×œ××™×œ×•×™ ×‘×¢×¨×š ×§×‘×•×¢ (0)
fill_zero_columns = [
    "BESS availability",
    "Inv Block1-Availability",
    "Inv Block2-Availability",
    "Power Plant Control"
    "POC BESS-Power (BESS Meter) min"
]

# ×¢××•×“×•×ª ×œ×˜×™×¤×•×œ ×‘××™× ×˜×¨×¤×•×œ×¦×™×” ×œ×™× ××¨×™×ª
linear_interp_columns = [
    "SOC",
    "BESS Meter-Exported Energy",
    "BESS Meter-Imported Energy",
    "Grid Meter-Exported Energy",
    "Grid Meter-Imported Energy",
    "PV Meter-Exported Energy",
    "PV Meter-Imported Energy",
    "Irradiance1",
    "Irradiance2",
    "Temperature 1",
    "Temperature2"
]

# ×˜×™×¤×•×œ ×‘×¢×¨×›×™× ×—×¡×¨×™× ×œ×¤×™ ×”×”×•×¨××•×ª
for col in fill_zero_columns:
    if col in df.columns:
        df[col] = df[col].fillna(0)

for col in linear_interp_columns:
    if col in df.columns:
        df[col] = df[col].interpolate(method='linear', limit_direction='both')

# ×§×¨×™× ×” ×××•×¦×¢×ª
df['irradiance_avg'] = (df['Irradiance1'] + df['Irradiance2']) / 2
df['site_power_potential'] = 15200 * (df['irradiance_avg'] / 1000)
df['surplus_power'] = (df['site_power_potential'] - 6000).clip(lower=0)
df['actual_bess_charge_power'] = df['surplus_power'].clip(upper=bess_charge_limit_kw)
df['actual_bess_charge_energy'] = df['actual_bess_charge_power'] * 0.25

#   ×•×”×§×¨×™× ×” ×”×××•×¦×¢×ª ×—×™×©×•×‘ ×”×¤×¨×©×™× ×œ×›×œ ×¢××•×“×•×ª ×”××§×•×¨
for col in df.columns:
    if df[col].dtype in [np.float64, np.int64]:
        df[f"delta_{col}"] = df[col].diff()

""" ×©×œ×‘ 2: ×‘×“×™×§×” ×©×œ × ×™×§×•×™ ×”× ×ª×•× ×™× ×•×”×›× ×¡×ª ×”×§×•×‘×¥"""

print("ğŸ” ××‘× ×” ×›×œ×œ×™ ×©×œ df:")
df.info()
print("\nğŸ§¾ ×¡×˜×˜×™×¡×˜×™×§×•×ª ×›×œ×œ×™×•×ª:")
print(df.describe())

# ×¡×™×›×•× ×¢×¨×›×™× ×—×¡×¨×™×
print("\nğŸ“‰ ×›××•×ª NaN ×‘×›×œ ×¢××•×“×”:")
print(df.isna().sum().sort_values(ascending=False))

# ×—×™×¤×•×© ×¢×¨×›×™× ××™× ×¡×•×¤×™×™×
print("\nâš ï¸ ×‘×“×™×§×ª ×¢×¨×›×™ inf ××• -inf:")
print(np.isinf(df.select_dtypes(include=[np.number])).sum())

# ×‘×“×™×§×ª ×¢××•×“×•×ª ×›×¤×•×œ×•×ª
print("\nğŸ§© ×‘×“×™×§×ª ×¢××•×“×•×ª ×›×¤×•×œ×•×ª:")
duplicated_cols = df.columns[df.T.duplicated()]
print(duplicated_cols)

#df = df.dropna()
# ×¡×™× ×•×Ÿ ×”×¢××•×“×•×ª ×©×¨×•×¦×™× ×œ×”×¡×™×¨
cols_to_drop = [col for col in df.columns if col.startswith('delta_') and col.endswith('_missing')]

# ×”×¡×¨×ª ×”×¢××•×“×•×ª
df = df.drop(columns=cols_to_drop)

print(f"×”×•×¡×¨×• {len(cols_to_drop)} ×¢××•×“×•×ª: {cols_to_drop}")

binary_cols = ['is_weekend', 'suspected_blackout', 'is_peak_time', 'bess_is_full', 'valid_for_PR']
existing_cols = [col for col in binary_cols if col in df.columns]
df[existing_cols] = df[existing_cols].apply(pd.to_numeric, errors='coerce')

df.info()

df.shape[1]

#  ×•×”×•×¡×¤×ª ×¢××•×“×•×ª

df['datetime'] = pd.to_datetime(df['Date'])
df['hour'] = df['datetime'].dt.hour + df['datetime'].dt.minute / 60
df['date'] = df['datetime'].dt.date

df['minute'] = df['Date'].dt.minute
df['dayofweek'] = df['Date'].dt.dayofweek
df['is_weekend'] = df['dayofweek'] >= 5
df['month'] = df['Date'].dt.month
df['abs_POC_BESS_Power'] = df['POC BESS-Power (BESS Meter) min'].abs()


# ×”×ª×™×—×¡×•×ª ×œ×–××™× ×•×™×•×ª
df['bess_available'] = (df['BESS availability'] == 100).astype(int)
df['pv_available'] = ((df['Inv Block1-Availability'] == 100) &
                      (df['Inv Block2-Availability'] == 100)).astype(int)
# ×©×œ×‘ 1: ×—×™×©×•×‘ ×¨××©×•× ×™ ×©×œ grid ratio
df['grid_ratio'] = df['Power Plant Control'] / grid_connection_limit_kw

# ×©×œ×‘ 2: ×ª× ××™ ×œ×—×©×“ ×œ×”×¤×¡×§×ª ×—×©××œ
# × × ×™×— ×©-pv_energy ×”×•× ×¢××•×“×” ×§×™×™××ª (×œ××©×œ PV Meter-Exported Energy)
df['suspected_blackout'] = (
    df['bess_available'].isna() &
    df['pv_available'].isna() &
    df['irradiance_avg'].isna() &
    (df['PV Meter-Exported Energy'] == 0)
)

# ×©×œ×‘ 3: ×§×‘×™×¢×ª ×–××™× ×•×ª ×¨×©×ª ×œ×¤×™ ×ª× ××™×
df['grid_available'] = (
    ((df['grid_ratio'] < 1) | df['suspected_blackout'])
).astype(int)

##test1
# ×©×œ×‘ 4: ×—×™×©×•×‘ ×©×¢×ª ×¤×¡×’×” ×œ×¤×™ ×˜×‘×œ×ª ×§×‘×•×¢×™×
peak_config = {
    1: (17, 22), 2: (17, 22), 3: (17, 22), 4: (17, 22), 5: (17, 22),
    6: (17, 23), 7: (17, 23), 8: (17, 23), 9: (17, 23),
    10: (17, 22), 11: (17, 22), 12: (17, 22)
}
df['is_peak_time'] = df.apply(lambda row: peak_config[row['month']][0] <= row['hour'] < peak_config[row['month']][1], axis=1)

def get_operation_zone(row):
    if  6 <= row['hour'] <= 16:
        return 'PV_active'
    elif row['is_peak_time']:
        return 'Discharge_peak'
    else:
        return 'Free_night'

df['operation_zone'] = df.apply(get_operation_zone, axis=1)

# ×©×œ×‘ 6: ×—×™×©×•×‘ ×”×¤×¨×©×™× ×œ×›×œ ×¢××•×“×•×ª ×”××§×•×¨
#for col in df.columns:
    #if df[col].dtype in [np.float64, np.int64]:
      #  df[f"delta_{col}"] = df[col].diff()
#××¢×›×©×™×• × ×ª×¢×œ× ×›×œ ×™×•× ××”×©×¢×” 00:15
mask = df['Date'].dt.time != pd.to_datetime("00:15").time()
df_filtered = df[mask]

# ×©×œ×‘ 5: ×—×™×©×•×‘×™× × ×•×¡×¤×™×





# ---------- ×©×œ×‘ ×‘': ×—×™×©×•×‘×™ ×¤×™×¦'×¨×™× ---------- #

# ×‘×“×™×§×ª ×”×× ×”×¡×•×œ×œ×” ××œ××”
df['bess_is_full'] = df['SOC'] >= 0.96

# ×”×× ×¨×‘×¢ ×”×©×¢×” ×ª×§×¤×” ×œ×—×™×©×•×‘ PR (×œ× ×›×©××™×Ÿ ×–××™× ×•×ª ××• ×©×”×¡×•×œ×œ×” ××œ××”)
df['valid_for_PR'] = (
    df['bess_available']
    & df['grid_available']
    & (~df['bess_is_full'])
)

# ×”×’×‘×œ×ª ×”×”×¡×¤×§ ×”×¤×•×˜× ×¦×™××œ×™ ×œ××§×¡×™××•× ×”××•×ª×¨
df['target'] = df['site_power_potential'].clip(upper=site_pv_limit)

# ×™×—×¡ ×‘×™×Ÿ ×™×™×¦×•×¨ ×‘×¤×•×¢×œ ×œ××§×¡×™××•× ××¤×©×¨×™ â€“ Target Rate
df['target_rate'] = df['delta_PV Meter-Exported Energy'] / df['target']

# ×—×™×©×•×‘ PR ×œ×¤×™ ×§×¨×™× ×” ×•×”×¡×¤×§ ××•×ª×§×Ÿ
df['PR'] = (
    df['delta_PV Meter-Exported Energy']
    / ((df['irradiance_avg'] / 4000) * site_capacity_kwp)
)
df['target_rate'] = np.nan_to_num(df['target_rate'], nan=0.0, posinf=0.0, neginf=0.0)
df['PR'] = np.nan_to_num(df['target_rate'], nan=0.0, posinf=0.0, neginf=0.0)


# ××™× ×“×™×§×¦×™×” ×œ××™ ×§×™×‘×œ ×¢×“×™×¤×•×ª ×§×•×“×: ×’×¨×™×“ ××• ×¡×•×œ×œ×”
df['first_grid_act'] = (
    df['delta_Grid Meter-Exported Energy'] > df['delta_BESS Meter-Imported Energy']
).astype(int)

df['first_bess_act'] = (
    df['delta_Grid Meter-Exported Energy'] < df['delta_BESS Meter-Imported Energy']
).astype(int)

# ×©×œ×‘ 6: ×—×™×©×•×‘×™× × ×•×¡×¤×™×
df['first_grid_act'] = (df['delta_Grid Meter-Exported Energy'] > df['delta_BESS Meter-Imported Energy']).astype(int)
df['first_bess_act'] = (df['delta_Grid Meter-Exported Energy'] < df['delta_BESS Meter-Imported Energy']).astype(int)

# ×—×™×©×•×‘ ××¦×‘ × ×•×›×—×™ ×‘×¡×•×œ×œ×” ×•×× ×¨×’×™×” × ×“×¨×©×ª
    df['energy_in_bess_kwh'] = df['SOC'] * bess_capacity_kwh
    df['energy_needed_kwh'] = (target_soc * bess_capacity_kwh) - df['energy_in_bess_kwh']

    # ×—×™×©×•×‘ ×›××•×ª ×“×§×•×ª × ×•×ª×¨×•×ª ×¢×“ 16:30
    CHARGE_END_MINUTES = 16 * 60 + 30
    df['time_in_minutes'] = df['datetime'].dt.hour * 60 + df['datetime'].dt.minute
    df['quarters_left'] = ((CHARGE_END_MINUTES - df['time_in_minutes']) / 15).clip(lower=0).astype(int)

    df.loc[0] = df.loc[0].replace([np.inf, -np.inf], np.nan).fillna(0)

# ×”×’× ×” ×¢×œ denominator
df = df.copy()

# ×˜×™×¤×•×œ ×‘××›× ×”: ×× ×”×•× 0, × ×—×œ×™×£ ×‘Ö¾NaN ×›×“×™ ×œ×”×™×× ×¢ ××—×œ×•×§×” ×‘××¤×¡
df['energy_needed_kwh'] = df['energy_needed_kwh'].fillna(0)

# ×—×™×©×•×‘ ×›××•×ª ×¨×‘×¢×™ ×”×©×¢×” ×”×“×¨×•×©×™× ×œ×˜×¢×™× ×” ××œ××” ×©×œ ×”×¡×•×œ×œ×”
#df['required_quarters'] = df['energy_needed_kwh'] / df['delta_BESS Meter-Imported Energy']
#df['required_quarters'] = (df['energy_needed_kwh'] /
                    #       df['abs_POC_BESS_Power'].where(df['abs_POC_BESS_Power'] > 0, 1)) * 4

df['required_quarters'] = (df['energy_needed_kwh'] /
                           df['abs_POC_BESS_Power'].mask(df['abs_POC_BESS_Power'] < 1, 1)) * 4

#df['required_quarters'] = df['required_quarters'].replace([np.inf, -np.inf], np.nan).fillna(0)

# ×—×™×©×•×‘ ×¢×“×™×¤×•×ª ×œ×¡×•×œ×œ×”: ×”×× ×™×© ××¡×¤×™×§ ×–××Ÿ ×¢×“ ×¡×•×£ ×”×™×•× ×›×“×™ ×œ×˜×¢×•×Ÿ ××ª ×”×¡×•×œ×œ×”
df['BESS First'] = (df['required_quarters'] > df['quarters_left']).astype(int)

# ×¨×§ ×œ×©×•×¨×” ×”×¨××©×•× ×”: ××™×œ×•×™ ×¢×¨×›×™× ×—×¡×¨×™× ××• ××™× ×¡×•×¤×™×™×
df.loc[0] = df.loc[0].replace([np.inf, -np.inf], np.nan).fillna(0)

#×‘×•×“×§×ª ×›××” ×¢××•×“×•×ª ×™×¦×¨×ª×™
df.shape[1]

df.to_excel("Stage2.xlsx", index=False)

"""×©×œ×‘ 2 × ×‘×—×¨ ××ª ×”×¢××•×“×•×ª ×”×›×™ ×¨×œ×•×•× ×˜×™×•×ª ×‘×¢×–×¨×ª random forest"""

df['date'] = pd.to_datetime(df['date']).map(lambda x: x.timestamp())
df_step1 = df.drop(columns=['Date','datetime', 'operation_zone'])
df_step1 = df_step1.dropna()

missing_rows = df_step1.isna().any(axis=1).sum()
print(f"××¡×¤×¨ ×©×•×¨×•×ª ×¢× ×¢×¨×›×™× ×—×¡×¨×™×: {missing_rows}")

# 3. ×©×œ×‘ ×©× ×™: Feature Selection ×œ×¤×™ ×—×©×™×‘×•×ª ×‘×¤×•×¢×œ â€“ Random Forest
# × ×’×“×™×¨ X ×•Ö¾y


# ×™×¦×™×¨×ª ×¢××•×“×ª 'BESS First' ×¢× ×¢×¨×š ×”×ª×—×œ×ª×™ ××¤×¡ (×œ×× ×™×¢×ª NaN)
#df_step1['BESS First'] = 0

# ×›××Ÿ ××¤×©×¨ ×œ×”×›× ×™×¡ ×ª× ××™ ×—×›× ×•×œ×”×—×œ×™×£ ×œÖ¾1 ×”×™×›×Ÿ ×©×¦×¨×™×š
# ×œ×“×•×’××” (×× ×™×© ×œ×š ×—×™×©×•×‘ ×œ×¤×™ required_quarters ×•×›×•')
 #df_step1.loc[condition, 'BESS First'] = 1

# ×¡×™× ×•×Ÿ ×œ×¤×™ ×©×¢×•×ª (9â€“ 6)
df_filtered = df_step1[(df_step1['hour'] >= 9) & (df_step1['hour'] <= 16)]

# ×”×¡×¨×” ×©×œ ×©×•×¨×•×ª ×¢× NaN, ×× ×‘×˜×¢×•×ª × ×•×ª×¨×•
df_filtered = df_filtered.dropna(subset=['BESS First'])

# ×™×¦×™×¨×ª X ×•Ö¾y ×¢×œ ×‘×¡×™×¡ ×¢××•×“×•×ª ××¡×¤×¨×™×•×ª ×‘×œ×‘×“
X = df_filtered.select_dtypes(include='number').drop(columns=['BESS First'])
y = df_filtered['BESS First'].astype(int)

df.shape[1]
missing_rows = df_filtered.isna().any(axis=1).sum()
print(f"××¡×¤×¨ ×©×•×¨×•×ª ×¢× ×¢×¨×›×™× ×—×¡×¨×™×: {missing_rows}")

# ××™××•×Ÿ ××•×“×œ
from sklearn.ensemble import RandomForestClassifier
from sklearn.feature_selection import SelectFromModel

rf = RandomForestClassifier(
    n_estimators=100,
    max_depth=10,
    min_samples_leaf=2,
    max_leaf_nodes=50,
    random_state=42
)
rf.fit(X, y)

# ×‘×—×™×¨×ª ×¤×™×¦'×¨×™× ×—×©×•×‘×™× ×‘×œ×‘×“
selector = SelectFromModel(rf, prefit=True)
X_selected = selector.transform(X)

# ×©××•×ª ×”×¤×™×¦'×¨×™× ×©× ×‘×—×¨×•
selected_features = X.columns[selector.get_support()].tolist()
print(f"\nâœ”ï¸ × ×‘×—×¨×• {len(selected_features)} ×¤×™×¦'×¨×™× ×—×©×•×‘×™×:")
print(selected_features)

manual_features = ['target_rate', 'SOC', 'hour','month']  # ×œ×“×•×’××”
X_manual = X[manual_features]
X_auto = X.drop(columns=manual_features)

# Apply Feature Selection ×¨×§ ×¢×œ X_auto
rf.fit(X_auto, y)
selector = SelectFromModel(rf, prefit=True)
auto_selected = X_auto.columns[selector.get_support()].tolist()

# ××™×—×•×“ ×¡×•×¤×™
selected_features = manual_features + auto_selected

print(selected_features)

missing_rows = X_auto.isna().any(axis=1).sum()
print(f"××¡×¤×¨ ×©×•×¨×•×ª ×¢× ×¢×¨×›×™× ×—×¡×¨×™×: {missing_rows}")

print("×™×© NaN?", X.isna().sum().sum())
print("×™×© inf?", (X == np.inf).sum().sum())
print("×™×© -inf?", (X == -np.inf).sum().sum())
missing_rows = X.isna().any(axis=1).sum()
print(f"××¡×¤×¨ ×©×•×¨×•×ª ×¢× ×¢×¨×›×™× ×—×¡×¨×™×: {missing_rows}")

#df_selected_final = df_selected_final.replace(['', ' ', 'nan', 'None'], np.nan)

# ×™×¦×™×¨×ª DataFrame ×¡×•×¤×™


df_filtered = df[(df['hour'] >= 9) & (df['hour'] < 16)].dropna(subset=['BESS First'])

# ×™×¦×™×¨×ª X ×•-y
X = df_filtered[selected_features]
y = df_filtered['BESS First'].astype(int)

# ××™×¤×•×¡ ××™× ×“×§×¡
X_reset = X.reset_index(drop=True)
y_reset = y.reset_index(drop=True)

# ×—×™×‘×•×¨ ×©× ×™ ×”×—×œ×§×™× ×œ-DataFrame ××—×“
df_selected_final = pd.concat([X_reset, y_reset], axis=1)


#df_selected_final = pd.concat([X[selected_features], y.reset_index(drop=True)], axis=1)

missing_rows = df_selected_final.isna().any(axis=1).sum()
print(f"××¡×¤×¨ ×©×•×¨×•×ª ×¢× ×¢×¨×›×™× ×—×¡×¨×™×: {missing_rows}")

num_rows_with_nan = df_selected_final.isna().any(axis=1).sum()
print(f"××¡×¤×¨ ×©×•×¨×•×ª ×¢× ×¢×¨×›×™× ×—×¡×¨×™× (NaN): {num_rows_with_nan}")

df_selected_final[df_selected_final.isna().any(axis=1)].index

df_selected_final[df_selected_final.isna().any(axis=1)].isna()

from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, accuracy_score

X_train, X_test, y_train, y_test = train_test_split(
    X[selected_features], y, test_size=0.2, stratify=y, random_state=42)

model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)
y_pred = model.predict(X_test)

print(classification_report(y_test, y_pred))
# ×¨××ª ×“×™×•×§ ×‘×¡×™×¡×™×ª
accuracy = accuracy_score(y_test, y_pred)
print(f"Accuracy: {accuracy:.3f}")

import pandas as pd
import matplotlib.pyplot as plt

# ×—×™×©×•×‘ ×—×©×™×‘×•×ª ×”×¤×™×¦'×¨×™×
importances = model.feature_importances_

feat_imp = pd.DataFrame({
    'Feature': selected_features,
    'Importance': importances
}).sort_values(by='Importance', ascending=False)

# ×”×“×¤×¡×”
print(feat_imp)

# ×’×¨×£
plt.figure(figsize=(10, 6))
plt.barh(feat_imp['Feature'], feat_imp['Importance'])
plt.gca().invert_yaxis()
plt.xlabel("×—×©×™×‘×•×ª")
plt.title("×—×©×™×‘×•×ª ×”×¤×™×¦'×¨×™× ×‘××•×“×œ Random Forest")
plt.tight_layout()
plt.show()

"""×¢×›×©×™×• ××—×¨×™ ×©×¨××™×ª×™ ××ª ×—×©×™×‘×•×ª ×”×¤×™×¦×¨×™× ×× ×™ ×¨×•×¦×” ×œ×”×•×¨×™×“ ×›××” ××”× ×‘××™×•×—×“ ××ª ×”×“×œ×ª××•×ª ×Ÿ××ª furst_bess_act  ×©×× ×™ ×œ× ×¨×•×¦×” ×©×”×•× ×™×ª×‘×¡×¡ ×¢×œ×™×•"""

#selected_features = [
 #   'SOC', 'hour', 'month',
   # 'energy_needed_kwh', 'required_quarters','PV Meter-Exported Energy','delta_BESS Meter-Imported Energy',
   # 'quarters_left', 'time_in_minutes','BESS Meter-Imported Energy',
#]

selected_features = [
    'SOC', 'hour', 'month','required_quarters','quarters_left','energy_needed_kwh','energy_in_bess_kwh',
    'PV Meter-Exported Energy',
    'BESS Meter-Imported Energy','PR','abs_POC_BESS_Power'
]

df_filtered = df[(df['hour'] >= 9) & (df['hour'] < 16)].dropna(subset=['BESS First'])
X = df_filtered [selected_features]
y = df_filtered ['BESS First']  # ×¢××•×“×ª ×”×™×¢×“ ×©×œ×š (0 ××• 1, ×œ×“×•×’××”)

# 3. ×—×œ×•×§×” ×œ××™××•×Ÿ ×•×‘×“×™×§×” (×œ× ×—×•×‘×” ×× ×›×‘×¨ ×”×›×œ ××•×›×Ÿ)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# 4. ××™××•×Ÿ ×”××•×“×œ
model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)
importances = model.feature_importances_
feat_imp = pd.DataFrame({
    'Feature': X_train.columns,
    'Importance': importances
}).sort_values(by='Importance', ascending=False)

# ×”×“×¤×¡×” ×•×’×¨×£
print(feat_imp)

plt.figure(figsize=(10, 6))
plt.barh(feat_imp['Feature'], feat_imp['Importance'])
plt.gca().invert_yaxis()
plt.title("×”×©×¤×¢×ª ×”×¤×™×¦'×¨×™× ×œ××—×¨ ×”×¡×¨×”")
plt.xlabel("×—×©×™×‘×•×ª")
plt.tight_layout()
plt.show()
# ×ª×—×–×™×ª ×¢×œ ×¡×˜ ×”×‘×“×™×§×”
y_pred = model.predict(X_test)

# ×“×•×— ×‘×™×¦×•×¢×™×
from sklearn.metrics import classification_report, accuracy_score

print(f"\n×“×™×•×§: {accuracy_score(y_test, y_pred):.3f}")
print(classification_report(y_test, y_pred))

import seaborn as sns
import matplotlib.pyplot as plt

corr_matrix = df[selected_features].corr()

plt.figure(figsize=(10, 8))
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt=".2f", square=True)
plt.title("××˜×¨×™×¦×ª ×§×•×¨×œ×¦×™×” ×‘×™×Ÿ ×¤×™×¦'×¨×™×")
plt.show()

from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, accuracy_score

#X_train, X_test, y_train, y_test = train_test_split(
   # X[selected_features], y, test_size=0.2, stratify=y, random_state=42)



selected_features = [
    'SOC', 'hour', 'month','required_quarters','quarters_left','energy_needed_kwh'
    ,'abs_POC_BESS_Power'
]

df_filtered = df[(df['hour'] >= 9) & (df['hour'] < 16)].dropna(subset=['BESS First'])
X = df_filtered [selected_features]
y = df_filtered ['BESS First']  # ×¢××•×“×ª ×”×™×¢×“ ×©×œ×š (0 ××• 1, ×œ×“×•×’××”)

# 3. ×—×œ×•×§×” ×œ××™××•×Ÿ ×•×‘×“×™×§×” (×œ× ×—×•×‘×” ×× ×›×‘×¨ ×”×›×œ ××•×›×Ÿ)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# 4. ××™××•×Ÿ ×”××•×“×œ

from sklearn.ensemble import RandomForestClassifier
from sklearn.feature_selection import SelectFromModel

model = RandomForestClassifier(
    n_estimators=100,
    max_depth=10,
    min_samples_leaf=2,
    max_leaf_nodes=50,
    random_state=42
)


#model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)
importances = model.feature_importances_
feat_imp = pd.DataFrame({
    'Feature': X_train.columns,
    'Importance': importances
}).sort_values(by='Importance', ascending=False)

# ×”×“×¤×¡×” ×•×’×¨×£
print(feat_imp)

plt.figure(figsize=(10, 6))
plt.barh(feat_imp['Feature'], feat_imp['Importance'])
plt.gca().invert_yaxis()
plt.title("×”×©×¤×¢×ª ×”×¤×™×¦'×¨×™× ×œ××—×¨ ×”×¡×¨×”")
plt.xlabel("×—×©×™×‘×•×ª")
plt.tight_layout()
plt.show()
# ×ª×—×–×™×ª ×¢×œ ×¡×˜ ×”×‘×“×™×§×”
y_pred = model.predict(X_test)

# ×“×•×— ×‘×™×¦×•×¢×™×
from sklearn.metrics import classification_report, accuracy_score

print(f"\n×“×™×•×§: {accuracy_score(y_test, y_pred):.3f}")
print(classification_report(y_test, y_pred))

from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, accuracy_score
from sklearn.ensemble import RandomForestClassifier
import matplotlib.pyplot as plt
import pandas as pd

# ---------------------------------------------------
# ğŸ¯ ×”×’×“×¨×ª ×”×¤×™×¦'×¨×™× â€” ×‘×œ×™ ×œ×›×œ×•×œ ××ª 'BESS First' ×›×¤×™×¦'×¨!
# ---------------------------------------------------
selected_features = [
    'SOC', 'hour', 'month',
    'required_quarters',        # × ×’×–×¨ ××ª×•×š SOC ×•Ö¾grid limit
    'quarters_left',            # × ×’×–×¨ ××ª×•×š ×”×©×¢×”
    'energy_needed_kwh',        # × ×’×–×¨ ××ª×•×š SOC
   # 'BESS Meter-Imported Energy', # ××“×“ ×¦×¨×™×›×” ××¦×˜×‘×¨×ª (××”×©×˜×—)
    'abs_POC_BESS_Power'
]

df_filtered = df[(df['hour'] >= 9) & (df['hour'] < 16)].dropna(subset=['BESS First'])
X = df_filtered [selected_features]
y = df_filtered ['BESS First']   # âœ… ××©×ª× ×” ××˜×¨×” â€“ × ×•×¦×¨ ×œ×¤×™ × ×•×¡×—×”: required > left

# ---------------------------------------------------
# ğŸ“¤ ×—×œ×•×§×” ×œ××™××•×Ÿ ×•×‘×“×™×§×” (××¤×©×¨ ×œ×”×•×¡×™×£ stratify)
# ---------------------------------------------------
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
)

# ---------------------------------------------------
# ğŸŒ² ××™××•×Ÿ ××•×“×œ ×™×¢×¨ ××§×¨××™
# ---------------------------------------------------
model = RandomForestClassifier(
    n_estimators=100,
    max_depth=10,
    min_samples_leaf=2,
    max_leaf_nodes=50,
    random_state=42
)
model.fit(X_train, y_train)

# ---------------------------------------------------
# ğŸ“Š ×—×©×™×‘×•×ª ×”×¤×™×¦'×¨×™×
# ---------------------------------------------------
importances = model.feature_importances_
feat_imp = pd.DataFrame({
    'Feature': X_train.columns,
    'Importance': importances
}).sort_values(by='Importance', ascending=False)

print(feat_imp)

plt.figure(figsize=(10, 6))
plt.barh(feat_imp['Feature'], feat_imp['Importance'])
plt.gca().invert_yaxis()
plt.title("×”×©×¤×¢×ª ×”×¤×™×¦'×¨×™× ×¢×œ ×”×”×—×œ×˜×” ×œ×ª×¢×“×£ ×˜×¢×™× ×”")
plt.xlabel("×—×©×™×‘×•×ª")
plt.tight_layout()
plt.show()

# ---------------------------------------------------
# ğŸ¯ ×ª×—×–×™×ª ×•×‘×“×™×§×ª ×“×™×•×§
# ---------------------------------------------------
y_pred = model.predict(X_test)

print(f"\n×“×™×•×§ (Accuracy): {accuracy_score(y_test, y_pred):.3f}")
print("×“×•×— ×¡×™×•×•×’:")
print(classification_report(y_test, y_pred))

print(f"len(y_test): {len(y_test)}")
print(f"len(y_pred): {len(y_pred)}")

print("×”×× ×™×© ×©×•× ×™ ×‘×™×Ÿ y_test ×œÖ¾y_pred?")
print((y_test != y_pred).sum())

import joblib
joblib.dump(model, 'bess_priority_model2.pkl')

import numpy as np
import pandas as pd
import joblib

# ×¨×©×™××ª ×”×¤×™×¦'×¨×™× (×—×™×™×‘×ª ×œ×”×ª××™× ×œ×¡×“×¨ ×©×‘×• ×”××•×“×œ ××•××Ÿ!)
selected_features = [
    'SOC',
    'hour',
    'month',
    'energy_needed_kwh',
    'required_quarters',
    'quarters_left',
    'abs_POC_BESS_Power',
    #'BESS Meter-Imported Energy',
    #'BESS First'  # â† ×›××Ÿ ××•×¡×™×¤×™× ××•×ª×•
]

# × ×ª×•× ×™ ××ª×¨ ×§×‘×•×¢×™×
site_capacity_kwp = 15200
grid_connection_limit_kw = 6000
bess_capacity_kwh = 0.99 * 35000  # SOC ×™×¢×“
bess_charge_limit_kw = 6000

# ×¤×•× ×§×¦×™×™×ª ×‘× ×™×™×ª ×¤×™×¦'×¨×™×
def prepare_features(input_dict):
    soc = input_dict['soc']
    hour = input_dict['hour']
    month = input_dict['month']
   # bess_imported = input_dict['BESS Meter-Imported Energy']



    BESS_Power = input_dict.get('abs_POC_BESS_Power', 0)
    if BESS_Power == 0:
        BESS_Power = 1

    energy_needed_kwh = bess_capacity_kwh * (1 - soc / 100)
    #required_quarters = np.ceil((energy_needed_kwh / grid_connection_limit_kw) * 4)
    required_quarters = np.ceil((energy_needed_kwh / BESS_Power) * 4)
    quarters_left = max(0, (16 - hour) * 4)

    bess_first = int(required_quarters > quarters_left)

    input_dict_full = {
        'SOC': soc,
        'hour': hour,
        'month': month,
        'energy_needed_kwh': energy_needed_kwh,
        'required_quarters': required_quarters,
        'quarters_left': quarters_left,
        'abs_POC_BESS_Power':BESS_Power,
   #    'BESS Meter-Imported Energy': bess_imported,
        'BESS First': bess_first# â† âœ¨ ×”×¤×™×¦'×¨ ×”×§×¨×™×˜×™
    }

    features = {key: input_dict_full[key] for key in selected_features}
    return pd.DataFrame([features])

    # ×™×¦×™×¨×ª DataFrame ×‘×¡×“×¨ ×¢××•×“×•×ª ××“×•×™×§ ×›×¤×™ ×©×”××•×“×œ ××•××Ÿ ×¢×œ×™×•
    return pd.DataFrame([input_dict_full])[selected_features]

# ×˜×¢×™× ×ª ×”××•×“×œ ×”×××•××Ÿ
model = joblib.load("bess_priority_model2.pkl")
selected_features = list(model.feature_names_in_)
print("Features used in model:")
print(model.feature_names_in_)


# ×¡×•×›×Ÿ ×©××§×‘×œ ×”×—×œ×˜×”

def decide_bess_priority(input_dict):
    features_df = prepare_features(input_dict)

    # ×©××•×ª ×©×”××•×“×œ ××¦×¤×” ×œ×”×
    expected_features = list(model.feature_names_in_)
    # ×©××•×ª ×©×”×’×™×¢×• ×‘×¤×•×¢×œ
    actual_features = list(features_df.columns)

    # ×‘×“×™×§×” ×× ×™×© ×—×•×¡×¨ ××• ×¢×•×“×¤×™×
    missing = [f for f in expected_features if f not in actual_features]
    extra = [f for f in actual_features if f not in expected_features]
    order_wrong = expected_features != actual_features

    # ×”×“×¤×¡×ª ×¤×¢×¨×™×
    if missing:
        print("âŒ ×¤×™×¦'×¨×™× ×—×¡×¨×™× ×‘×“××˜×”:", missing)
    if extra:
        print("âš ï¸ ×¤×™×¦'×¨×™× ××™×•×ª×¨×™× ×‘×“××˜×”:", extra)
    if order_wrong and not missing and not extra:
        print("âš ï¸ ×¡×“×¨ ×”×¤×™×¦'×¨×™× ×©×•× ×” ×××” ×©×”××•×“×œ ×¦×™×¤×” ×œ×•.")
        print("××¦×•×¤×”:", expected_features)
        print("××‘×œ ×‘×¤×•×¢×œ:", actual_features)

    if missing or extra or order_wrong:
        print("â›” ×œ× × ×‘×¦×¢ ×ª×—×–×™×ª ×¢×“ ×©×”×¤×¢×¨ ×™×ª×•×§×Ÿ.")
        return "×©×’×™××”: × ×ª×•× ×™ ×§×œ×˜ ×œ× ×ª×•×××™× ×œ××•×“×œ"

    # ×× ×”×›×•×œ ×ª×§×™×Ÿ â€“ × ×‘×¦×¢ ×ª×—×–×™×ª
    prediction = model.predict(features_df)[0]
    return "âœ… ×˜×¢×™× ×ª BESS ×‘×¢×“×™×¤×•×ª" if prediction == 1 else "ğŸŸ¡ ××™×Ÿ ×¦×•×¨×š ×‘×¢×“×™×¤×•×ª ×œÖ¾BESS"

# ×“×•×’××” ×œ×©×™××•×©
sample_input = {
    'soc': 1,
    'hour': 12,
    'month': 4,
    'BESS_Power': 5000,
}

# ×”×“×¤×¡×ª ×”×”×—×œ×˜×”
print(decide_bess_priority(sample_input))

from sklearn.tree import DecisionTreeClassifier, plot_tree
import matplotlib.pyplot as plt

# ××™××•×Ÿ ×¢×¥ ×”×—×œ×˜×” ×¤×©×•×˜
dt_model = DecisionTreeClassifier(max_depth=4, random_state=42)
dt_model.fit(X_train, y_train)

# ×¦×™×•×¨ ×”×¢×¥
plt.figure(figsize=(20,10))
plot_tree(dt_model, feature_names=X.columns, class_names=['No Charge', 'Charge'], filled=True)
plt.show()

from sklearn.tree import export_graphviz
import graphviz

dot_data = export_graphviz(
    dt_model, out_file=None,
    feature_names=X.columns,
    class_names=['No Charge', 'Charge'],
    filled=True, rounded=True,
    special_characters=True
)
graph = graphviz.Source(dot_data)
graph.render("decision_tree")  # ×™×™×¦×•×¨ ×§×•×‘×¥

def interactive_decision(soc, hour, month, BESS_Power):
    input_dict = {
        'soc': soc,
        'hour': hour,
        'month': month,
        #'BESS Meter-Imported Energy': bess_imported
        'abs_POC_BESS_Power':BESS_Power
    }

    features_df = prepare_features(input_dict)
    prediction = model.predict(features_df)[0]

    print("ğŸ“Š ×¤×™×¦'×¨×™× ×©×—×•×©×‘×• ×œ××•×“×œ:")
    display(features_df)

    print(f"ğŸ” ×ª×•×¦××ª ×”××•×“×œ (raw): {prediction}")

    if prediction == 1:
        result = "âœ… ×˜×¢×™× ×ª BESS ×‘×¢×“×™×¤×•×ª"
    elif prediction == 0:
        result = "ğŸŸ¡ ××™×Ÿ ×¦×•×¨×š ×‘×¢×“×™×¤×•×ª ×œÖ¾BESS"
    else:
        result = "âš ï¸ ×©×’×™××”: ×ª×—×–×™×ª ×œ× ×¦×¤×•×™×” ××”××•×“×œ"

    print("ğŸ” ×ª×•×¦××”:", result)

from ipywidgets import interact, IntSlider
interact(
    interactive_decision,
    soc=IntSlider(min=0, max=100, value=75),
    hour=IntSlider(min=9, max=16, value=12),
    month=IntSlider(min=1, max=12, value=4),
    BESS_Power=IntSlider(min=0, max=6000, value=5000)
)